main:
  steps:
    - init:
        assign:
          - project_id: ${sys.get_env("PROJECT_ID")}
          - location: ${sys.get_env("REGION")}
          # The list of steps matches the keys in cloud_run.tf
          - steps_list:
              - "apply_migrations"
              - "create_allocation_snapshots"
              - "fetch_ohlcv_coinmarketcap"
              - "fetch_gas_ethgastracker"
              - "fetch_defillama_pools"
              - "fetch_defillama_pool_addresses"
              - "fetch_account_transactions"
              - "fetch_macroeconomic_data"
              - "filter_pools_pre"
              - "fetch_filtered_pool_histories"
              - "calculate_pool_metrics"
              - "apply_pool_grouping"
              - "process_icebox_logic"
              - "update_allocation_snapshots"
              - "forecast_pools"
              - "forecast_gas_fees"
              - "filter_pools_final"
              - "process_account_transactions" # Note: order matters if there are dependencies
              - "manage_ledger"
              - "optimize_allocations"
              - "post_slack_notification"

    - run_pipeline_steps:
        for:
          value: step_key
          index: step_index
          in: ${steps_list}
          steps:
            - construct_job_name:
                assign:
                  # Replicate Terraform's naming logic: "pipeline-step-" + step_key (with _ replaced by -)
                  - job_name: ${"pipeline-step-" + text.replace_all(step_key, "_", "-")}
            
            - log_current_step:
                call: sys.log
                args:
                  data: '${"=== Starting step " + string(step_index + 1) + " -> " + job_name + " ==="}'

            - log_job_details:
                call: sys.log
                args:
                  data: '${"Running job: " + job_name + " in project " + project_id + ", location " + location}'

            - run_job:
                try:
                  call: googleapis.run.v1.namespaces.jobs.run
                  args:
                    # Construct the full resource name dynamically
                    name: ${"namespaces/" + project_id + "/jobs/" + job_name}
                    location: ${location}
                    body: {}
                    connector_params:
                      timeout: 3600  # Increased from default 1800 to 3600 seconds (1 hour)
                  result: job_execution
                except:
                  as: e
                  steps:
                    - log_run_error:
                        call: sys.log
                        args:
                          data: '${"Error starting job -> " + text.decode(json.encode(e))}'
                    - fail_with_details:
                        raise: '${"Failed to start job " + job_name + " at step " + string(step_index + 1) + ": " + text.decode(json.encode(e))}'

            - log_job_execution_details:
                call: sys.log
                args:
                  data: '${"Job execution started -> " + job_execution.metadata.name}'

            - check_job_success:
                switch:
                  - condition: ${job_execution.status.succeededCount == 1}
                    steps:
                      - log_success:
                          call: sys.log
                          args:
                            data: '${"âœ“ Step " + string(step_index + 1) + " completed successfully"}'
                  - condition: true
                    steps:
                      - log_failure:
                          call: sys.log
                          args:
                            data: '${"âœ— Step " + string(step_index + 1) + " failed. Status: " + json.encode(job_execution.status)}'
                      - fail_pipeline:
                          raise: '${"Pipeline failed at step " + string(step_index + 1) + ". Check logs for details."}'
        next: final_step

    - final_step:
        call: sys.log
        args:
          data: "ðŸŽ‰ All pipeline steps completed successfully!"
        next: complete

    - complete:
        return: "Workflow completed successfully"